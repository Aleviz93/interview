# 1. Для чего используется метод Function.prototype.apply и call?

Apply используется для привязки определенного объекта к значению this вызываемой функции.
Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива.
```
const person = {
    name: 'Marko Polo'
}

function greeting(greetingMessage) {
    return `${greetingMessage} ${this.name}`
}

greeting.apply(person, ['Hello']) // Hello Marko Polo

```
# 2. Что такое область видимости (Scope)?

Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).

Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.
```
var g = 'global'

function globalFunc() {
    function innerFunc() {
        console.log(g)
    }
    innerFunc()
}

// имеет доступ к переменной g, поскольку она является глобальной
```
Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.
```
function myFavouriteFunc(a) {
    if (true) {
        var b = 'Hello ' + a
    }
    return b
}
myFavouriteFunc('World')

console.log(a)
console.log(b)

console.log(a) // Uncaught ReferenceError: a is not defined
console.log(b) // не выполнится
```
Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.
```
function testBlock() {
    if (true) {
        let z = 5
    }
    return z
}

testBlock() // Uncaught ReferenceError: z is not defined
```

# 3. Какое значение имеет this?

Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this.
```
const carDetails = {
    name: 'Ford Mustang',
    yearBought: 2005,
    getName() {
        return this.name
    }
    isRegistered: true
}

console.log(carDetails.getName()) // Ford Mustang
```
В данном случае метод getName возвращает this.name, а this ссылается на carDetails, объект, в котором выполняется getName, который является ее «владельцем».

Добавим после console.log три строчки:
```
var name = 'Ford Ranger'
var getCarName = carDetails.getName

console.log(getCarName()) // Ford Ranger
```
Второй console.log выдает Ford Ranger, и это странно. Причина такого поведения заключается в том, что «владельцем» getCarName является объект window. Переменные, объявленные с помощью ключевого слова «var» в глобальной области видимости, записываются в свойства объекта window. this в глобальной области видимости ссылается на объект window (если речь не идет о строгом режиме).

# 4. Что такое промисы (Promises)? Как выполнить запросы параллельно, обработать результат (успешные, неуспешные)?

Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».

У промиса есть четыре состояния:

Ожидание — начальное состояние промиса. Результата промиса неизвестен, поскольку операция не завершена.
Выполнено — асинхронная операция выполнена, имеется результат.
Отклонено — асинхронная операция не выполнена, имеется причина.
Завершено — выполнено или отклонено.

В качестве параметров конструктор промиса принимает resolve и reject. В resolve записывается результат выполнения операции, в reject — причина невыполнения операции. Результат может быть обработан в методе .then, ошибка — в методе .catch. Метод .then также возвращает промис, поэтому мы можем использовать цепочку, состоящую из нескольких .then.
```
const myPromiseAsync = (...args) => {
    return new Promise((resolve, reject) => {
        doSomeAsync(...args, (error, data) => {
            if(error){
                reject(error)
            } else{
                resolve(data)
            }
        })
    })
}

myPromiseAsync()
.then(result => {
    console.log(result)
})
.catch(reason => {
    console.error(reason)
})
```
# 5. Что такое async/await?
Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова. Однако для использования async/await необходимо хорошо знать промисы.

promise
```
function callApi(){
    return fetch('url/to/api/endpoint')
    .then(resp => resp.json())
    .then(data => {
        // работаем с данными
    }).catch(err => {
        // работаем с ошибкой
    })
}
```
async/await для перехвата ошибок использует try/catch
```
async function callApi(){
    try{
        const resp = await fetch('url/to/api/endpoint')
        const data = await res.json()
        // работаем с данными
    } catch(e){
        // работаем с ошибкой
    }
}
```
использование ключевого слова «async» перед функцией заставляет ее возвращать промис:

Ключевое слово «await» можно использовать только внутри асинхронной функции. Использование «await» внутри другой функции приведет к ошибке. Await ожидает завершения выражения справа, чтобы вернуть его значение перед выполнением следующей строчки кода.

# 6. Websocket
Протокол WebSocket (стандарт RFC 6455) предназначен для решения любых задач и снятия ограничений обмена данными между браузером и сервером.
Он позволяет пересылать любые данные, на любой домен, безопасно и почти без лишнего сетевого трафика.
Для открытия соединения достаточно создать объект WebSocket, указав в нём специальный протокол ws.:
```
var socket = new WebSocket("ws://javascript.ru/ws");
```
У объекта socket есть четыре колбэка: один при получении данных и три – при изменениях в состоянии соединения:
```
socket.onopen = function() {
  alert("Соединение установлено.");
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert('Соединение закрыто чисто');
  } else {
    alert('Обрыв соединения'); // например, "убит" процесс сервера
  }
  alert('Код: ' + event.code + ' причина: ' + event.reason);
};

socket.onmessage = function(event) {
  alert("Получены данные " + event.data);
};

socket.onerror = function(error) {
  alert("Ошибка " + error.message);
};
```
Для посылки данных используется метод socket.send(data). Пересылать можно любые данные.

# 7. В чём отличия технологии Long Polling, протокола WebSocket и событий, генерируемых сервером?

Технология Long Polling применяется при взаимодействии клиентских и серверных систем. Клиент отправляет серверу запрос, ответ на который поступает тогда, когда в распоряжении сервера оказываются данные, запрошенные клиентом. После этого клиент выполняет новый запрос.
Протокол WebSocket позволяет устанавливать долгоживущие двусторонние соединения между клиентом и сервером.
В основе событий, генерируемых сервером, лежит использование долгоживущего HTTP-соединения, которое используется для отправки клиенту новых данных по инициативе сервера.


# 8. Преобразовать массив в объект.
Метод assign() может итеративно считывать свойства одного или нескольких объектов в целевой объект. Возвращает целевой объект.
```
const array = ['foo', 'boo', 'zoo'];
const obj = Object.assign({}, array);
console.log(obj)

{0: "foo", 1: "boo", 2: "zoo"}
```
Метод reduce() может применять функцию (которую вы предоставляете) к каждому элементу массива. Он возвращает одно выходное значение.
```
const array = ['foo', 'boo', 'zoo']
array.reduce(function(target, key, index) {
  target[index] = key;
  return target;
}, {}) //initial empty object

{0: "foo", 1: "boo", 2: "zoo"}
```
Оператора Spread для преобразования массива в объект в JavaScript
```
const arr = ["foo", "boo", "zoo"];
const obj = {...arr};
console.log(obj);

{0: "foo", 1: "boo", 2: "zoo"}
```

# 9. Classes
Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование

# 10. Замыкания 

Замыкание в JavaScript - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей обращаться к переменным и функциям этого лексического окружения в дальнейшем.

```
function makeCounter(initial = 0) {
  let counter = initial;

  return function() {
    return counter += 1;
  }
}

const counterA = makeCounter(0);

console.log(counterA()); // 1
console.log(counterA()); // 2

const counterB = makeCounter(100);

console.log(counterB()); // 101
console.log(counterB()); // 102
```

# 11. Методы массивов
* Array.prototype.at() 
принимает значение в виде целого числа и возвращает элемент массива с данным индексом. В качестве аргумента метод принимает положительные и отрицательные числа. При отрицательном значении отсчёт происходит с конца массива. Получение элементов массива с помощью квадратных скобок по-прежнему остаётся корректным способом. Например, array[0] вернёт первый элемент. Однако, при работе с элементами в конце массива больше нет необходимости прибегать к array.length. Например, для получения последнего элемента, вместо array[array.length-1] можно вызвать array.at(-1)

* Array.prototype.concat()
возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.

* Array.prototype.copyWithin()
```
arr.copyWithin(target, start[, end = this.length])
```
Метод копирует последовательность элементов массива внутри него в позицию, начинающуюся по индексу target. Копия берётся по индексам, задаваемым вторым и третьим аргументами start и end. Аргумент end является необязательным и по умолчанию равен длине массива. 

* Array.prototype.entries()
Метод последовательно возвращает новый объект итератора массива Array Iterator, содержащий пары ключ / значение для каждого индекса в массиве.

* Array.prototype.every()
проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции

* Array.prototype.fill()
заполняет все элементы массива от начального до конечного индексов одним значением.

* Array.prototype.filter()
создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.

* Array.prototype.find(callback)
возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции.  В противном случае возвращается undefined.

* Array.prototype.findIndex(callback)
возвращает индекс найденного в массиве элемента вместо его значения.

* Array.prototype.flat()
возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень depth.

* Array.prototype.flatMap()
сначала применяет функцию к каждому элементу, а затем преобразует полученный результат в плоскую структуру и помещает в новый массив. Это идентично map функции, с последующим применением функции flat с параметром depth ( глубина ) равным 1, но flatMap часто бывает полезным, так как работает немного более эффективно.

* Array.prototype.forEach()
выполняет указанную функцию один раз для каждого элемента в массиве.

* Array.from()
создаёт новый экземпляр Array из массивоподобного или итерируемого объекта.

* Array.prototype.includes()
определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

* Array.prototype.indexOf()
возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет

* Array.isArray()
возвращает true, если объект является массивом и false, если он массивом не является.

* Array.prototype.join()
объединяет все элементы массива (или массивоподобного объекта) в строку.

* Array.prototype.keys()
возвращает новый итератор массива Array Iterator, содержащий ключи каждого индекса в массиве.

* Array.prototype.lastIndexOf()
возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. Массив просматривается от конца к началу, начиная с индекса fromIndex.

* Array.prototype.map()
создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

* Array.of()
cоздаёт новый экземпляр массива Array из произвольного числа аргументов, вне зависимости от числа или типа аргумента.

* Array.prototype.pop()
удаляет последний элемент из массива и возвращает его значение

* Array.prototype.push()
добавляет один или более элементов в конец массива и возвращает новую длину массива.

* Array.prototype.reduce()
применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.
```
const array1 = [1, 2, 3, 4];
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (previousValue, currentValue) => previousValue + currentValue,
  initialValue
);
console.log(sumWithInitial); // expected output: 10
```

* Array.prototype.reduceRight()
в другую сторону

* Array.prototype.reverse()
* Array.prototype.shift()
* Array.prototype.unshift()

* Array.prototype.slice()
возвращает новый массив, содержащий копию части исходного массива.

* Array.prototype.some()
проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.

* Array.prototype.sort()
* Array.prototype.splice()
 изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.

* Array.prototype.toLocaleString()
 возвращает строковое представление элементов массива. Элементы преобразуются в строки с использованием своих собственных методов toLocaleString и эти строки разделяются локале-зависимой строкой (например, запятой «,»).

* Array.prototype.toSource()
* Array.prototype.toString()
* Array.prototype.values()
возвращает новый объект итератора массива Array Iterator, содержащий значения для каждого индекса в массиве.
```
var arr = ['w', 'y', 'k', 'o', 'p'];
var eArr = arr.values();
for (let letter of eArr) {
  console.log(letter);
}
```
```
var arr = ['w', 'y', 'k', 'o', 'p'];
var eArr = arr.values();
console.log(eArr.next().value); // w
console.log(eArr.next().value); // y
console.log(eArr.next().value); // k
console.log(eArr.next().value); // o
console.log(eArr.next().value); // p
```