# Общие:
# 1. Какие методы HTTP-запросов вы знаете?
```
GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.

HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.

POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.

PUT заменяет все текущие представления ресурса данными запроса.

DELETE удаляет указанный ресурс.

CONNECT устанавливает "туннель" к серверу, определённому по ресурсу.

OPTIONS используется для описания параметров соединения с ресурсом.

TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.

PATCH используется для частичного изменения ресурса.

```
# Частичные GET
```
Частичные GET
HTTP позволяет запросить не сразу всё содержимое ресурса, а только указанный фрагмент. Такие запросы называются частичные GET; возможность их выполнения необязательна (но желательна) для серверов. Частичные GET в основном используются для докачки файлов и быстрого параллельного скачивания в нескольких потоках. Некоторые программы скачивают заголовок архива, выводят пользователю внутреннюю структуру, а потом уже запрашивают фрагменты с указанными элементами архива.

Для получения фрагмента клиент посылает серверу запрос с заголовком Range, указывая в нём необходимые байтовые диапазоны. Если сервер не понимает частичные запросы (игнорирует заголовок Range), то он вернёт всё содержимое со статусом 200, как и при обычном GET. В случае успешного выполнения сервер возвращает вместо кода 200 ответ со статусом 206 (Partial Content), включая в ответ заголовок Content-Range. Сами фрагменты могут быть переданы двумя способами:

В ответе помещается заголовок Content-Range с указанием байтовых диапазонов. В соответствии с ними фрагменты последовательно помещаются в основное тело. При этом Content-Length должен соответствовать суммарному объёму всего тела;
Сервер указывает медиатип multipart/byteranges для основного содержимого и передаёт фрагменты, указывая соответствующий Content-Range для каждого элемента (см. также «Множественное содержимое»[⇨]).
```
# Условные GET
```
Условные GET
Метод GET изменяется на «условный GET», если сообщение запроса включает в себя поле заголовка If-Modified-Since. В ответ на «условный GET» тело запрашиваемого ресурса передаётся, только если он изменялся после даты, указанной в заголовке If-Modified-Since. Алгоритм определения этого включает в себя следующие случаи:

Если статус ответа на запрос будет отличаться от «200 OK» или дата, указанная в поле заголовка «If-Modified-Since», некорректна, ответ будет идентичен ответу на обычный запрос GET.
Если после указанной даты ресурс изменялся, ответ будет также идентичен ответу на обычный запрос GET.
Если ресурс не изменялся после указанной даты, сервер вернет статус «304 Not Modified».
Использование метода «условный GET» направлено на разгрузку сети, так как он позволяет не передавать по сети избыточную информацию.
```

# 2. Какие знаете коды ответа (состояния) HTTP?
```
Информационные 100 - 199
Успешные 200 - 299
Перенаправления 300 - 399
Клиентские ошибки 400 - 499
Серверные ошибки 500 - 599
```
# 3. Что такое агент пользователя? Или User-Agent header 
```
Пользовательский агент (user agent, UA), или агент пользователя, это компьютерная программа, представляющая пользователя и выполняющая действия от его лица, например, браузер в контексте Всемирной паутины.

Агентом пользователя может быть не только браузер, но и бот, удаляющий веб-страницы, менеджер закачек или другое приложение, использующее Веб. Выполняя запросы к серверу, браузеры, чтобы была возможность их идентифицировать, снабжают каждый запрос так называемой строкой пользовательского агента (UA-строкой), завёрнутой в HTTP-заголовок User-Agent. Это строка идентифицирует браузер, сообщает номер его версии и информацию об операционной системе.

Спам-боты, менеджеры закачек и некоторые браузеры нередко шлют подложные UA-строки, чтобы выдать себя за другие клиенты. Эта ситуация известна под названием подмена или подделка пользовательского агента (user agent spoofing).

Строчку пользовательского агента можно прочитать на стороне клиента с помощью JavaScript, обратившись к свойству navigator.userAgent.

Типичная UA-строка выглядит так: "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0". 
```
# 4. Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?
```
Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

Пример cross-origin запроса: HTML страница, обслуживаемая сервером с http://domain-a.com, запрашивает <img> src по адресу http://domain-b.com/image.jpg. Сегодня многие страницы загружают ресурсы вроде CSS-стилей, изображений и скриптов с разных доменов, соответствующих разным сетям доставки контента (Content delivery networks, CDNs).

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.
```
# Устранение проблем
```
Со стороны клиента подставляем дополнительный заголовок Origin в HTTP-запрос.

Если мы создаём сервер, к которому должен иметь доступ сайт https://mywebsite.com, то нужно внести этот домен в значение заголовка Access-Control-Allow-Origin.
```

# 5. Что такое cookie, sessionStorage, localStorage? Отличия.
```
 sessionStorage - хранилище сессии. И в данном случае, сессия, к которой мы обращаемся — это конкретная вкладка браузера, а не браузер или окно.
 Главное преимущество sessionStorage перед глобальной переменной JavaScript в том, что оно сохраняется после перезагрузки страницы.

 localStorage в отличие от sessionStorage сохраняет свои данные для всего приложения. У localStorage нет времени очистки. Потенциально эта информация будет храниться в браузере вечно. Возможность записи в localStorage доступна не всегда. Например, iOS Safari вернёт ошибку при попытке записать в localStorage, если браузер находится в приватном режиме. Для работы с localStorage используются методы getItem и setItem. localStorage работает не со всеми типами данных

 Cookies тоже являются domain specific, то есть привязаны только к конкретному домену, могут храниться очень долго. Но, в отличие от прошлых хранилищ, они пересылаются с каждым исходящим HTTP/HTTPS запросом на сервер. Их можно читать и записывать со стороны сервера. При записи они будут добавлены в HTTP ответ, чтобы браузер пользователя их запомнил.
```

// 6. Какой максимальный размер cookie?

// 7. Что означает директива use strict?

// 8. Чем JS отличается при работе на front-end и back-end?

// 9. Что такое статическая и динамическая типизации?

// 10. Как клиент взаимодействует с сервером?

// 11. Что такое REST?

// 12. Объяснить понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?

// 13. Как искать ошибки в коде? Используете ли вы дебаггер?

// 14. Каких известных людей из мира JS знаете?