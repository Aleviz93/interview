# Попросить рассказать о себе
# Что приходилось делать в области фротенда, какие технологии использовались
# Какой самый сложный с технической точки зрения проект делался
# https://code.yandex-team.ru/
# 1. Какие методы HTTP-запросов вы знаете?

* GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.

* HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.

* POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.

* PUT заменяет все текущие представления ресурса данными запроса.

* DELETE удаляет указанный ресурс.

* CONNECT устанавливает "туннель" к серверу, определённому по ресурсу.

* OPTIONS используется для описания параметров соединения с ресурсом.

* TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.

* PATCH используется для частичного изменения ресурса.

### Частичные GET

HTTP позволяет запросить не сразу всё содержимое ресурса, а только указанный фрагмент. Такие запросы называются частичные GET; возможность их выполнения необязательна (но желательна) для серверов. Частичные GET в основном используются для докачки файлов и быстрого параллельного скачивания в нескольких потоках. Некоторые программы скачивают заголовок архива, выводят пользователю внутреннюю структуру, а потом уже запрашивают фрагменты с указанными элементами архива.

Для получения фрагмента клиент посылает серверу запрос с заголовком Range, указывая в нём необходимые байтовые диапазоны. Если сервер не понимает частичные запросы (игнорирует заголовок Range), то он вернёт всё содержимое со статусом 200, как и при обычном GET. В случае успешного выполнения сервер возвращает вместо кода 200 ответ со статусом 206 (Partial Content), включая в ответ заголовок Content-Range. Сами фрагменты могут быть переданы двумя способами:

В ответе помещается заголовок Content-Range с указанием байтовых диапазонов. В соответствии с ними фрагменты последовательно помещаются в основное тело. При этом Content-Length должен соответствовать суммарному объёму всего тела;
Сервер указывает медиатип multipart/byteranges для основного содержимого и передаёт фрагменты, указывая соответствующий Content-Range для каждого элемента (см. также «Множественное содержимое»[⇨]).
### Условные GET

Метод GET изменяется на «условный GET», если сообщение запроса включает в себя поле заголовка If-Modified-Since. В ответ на «условный GET» тело запрашиваемого ресурса передаётся, только если он изменялся после даты, указанной в заголовке If-Modified-Since. Алгоритм определения этого включает в себя следующие случаи:

Если статус ответа на запрос будет отличаться от «200 OK» или дата, указанная в поле заголовка «If-Modified-Since», некорректна, ответ будет идентичен ответу на обычный запрос GET.
Если после указанной даты ресурс изменялся, ответ будет также идентичен ответу на обычный запрос GET.
Если ресурс не изменялся после указанной даты, сервер вернет статус «304 Not Modified».
Использование метода «условный GET» направлено на разгрузку сети, так как он позволяет не передавать по сети избыточную информацию.

# 2. Какие знаете коды ответа (состояния) HTTP?

* Информационные 100 - 199
* Успешные 200 - 299
* Перенаправления 300 - 399
* Клиентские ошибки 400 - 499
* Серверные ошибки 500 - 599
# 3. Что такое агент пользователя? Или User-Agent header 

Пользовательский агент (user agent, UA), или агент пользователя, это компьютерная программа, представляющая пользователя и выполняющая действия от его лица, например, браузер в контексте Всемирной паутины.

Агентом пользователя может быть не только браузер, но и бот, удаляющий веб-страницы, менеджер закачек или другое приложение, использующее Веб. Выполняя запросы к серверу, браузеры, чтобы была возможность их идентифицировать, снабжают каждый запрос так называемой строкой пользовательского агента (UA-строкой), завёрнутой в HTTP-заголовок User-Agent. Это строка идентифицирует браузер, сообщает номер его версии и информацию об операционной системе.

Спам-боты, менеджеры закачек и некоторые браузеры нередко шлют подложные UA-строки, чтобы выдать себя за другие клиенты. Эта ситуация известна под названием подмена или подделка пользовательского агента (user agent spoofing).

Строчку пользовательского агента можно прочитать на стороне клиента с помощью JavaScript, обратившись к свойству navigator.userAgent.

Типичная UA-строка выглядит так: "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0". 

# 4. Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

Пример cross-origin запроса: HTML страница, обслуживаемая сервером с http://domain-a.com, запрашивает <img> src по адресу http://domain-b.com/image.jpg. Сегодня многие страницы загружают ресурсы вроде CSS-стилей, изображений и скриптов с разных доменов, соответствующих разным сетям доставки контента (Content delivery networks, CDNs).

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.

# Устранение проблем

Со стороны клиента подставляем дополнительный заголовок Origin в HTTP-запрос.

Если мы создаём сервер, к которому должен иметь доступ сайт https://mywebsite.com, то нужно внести этот домен в значение заголовка Access-Control-Allow-Origin.

# 5. Что такое cookie, sessionStorage, localStorage? Отличия.

*  sessionStorage - хранилище сессии. И в данном случае, сессия, к которой мы обращаемся — это конкретная вкладка браузера, а не браузер или окно.
 Главное преимущество sessionStorage перед глобальной переменной JavaScript в том, что оно сохраняется после перезагрузки страницы. Но стирается после закрытия окна.

*  localStorage в отличие от sessionStorage сохраняет свои данные для всего приложения. У localStorage нет времени очистки. Потенциально эта информация будет храниться в браузере вечно. Возможность записи в localStorage доступна не всегда. Например, iOS Safari вернёт ошибку при попытке записать в localStorage, если браузер находится в приватном режиме. Для работы с localStorage используются методы getItem и setItem. localStorage работает не со всеми типами данных

*  Cookies тоже являются domain specific, то есть привязаны только к конкретному домену, могут храниться очень долго. Но, в отличие от прошлых хранилищ, они пересылаются с каждым исходящим HTTP/HTTPS запросом на сервер. Их можно читать и записывать со стороны сервера. При записи они будут добавлены в HTTP ответ, чтобы браузер пользователя их запомнил.

# 6. Какой максимальный размер cookie?

Браузер должен хранить не более 300 cookie по 4096 байт каждая, и не более 20 cookie для одного сервера или домена.

# 7. Что означает директива use strict?

"use strict"; (перевод: «использовать строгий») - это установка, которая заставляет код обрабатываться в строгом режиме. Без этой установки код обрабатывается в неограниченном режиме.

Строгий режим был введён в ECMAScript 5, и старые браузеры (IE9 и младше) его не поддерживают. То есть, не обращают внимания на установку по умолчанию и всё обрабатывается в неограниченном режиме.

В "use strict" некоторые ошибки можно найти быстрее, более опасные и не полезные черты JavaScript либо запрещены, либо приводят к ошибке.

В строгом режиме:
* нельзя присваивать значение в неопределённую переменную (спецификация §11.13.1). В неограниченном режиме создается глобальная переменная.
* нельзя присваивать значение в свойство данных только для чтения.
* нельзя использовать инструкцию with (спецификация §12.10).
* нельзя определить повторные формальные параметры функции (спецификация §13.1, §15.3.2).
* изменения объекта arguments не изменяют аргументы (спецификация §10.6).
* delete приводит к ошибке, если аргумент - не изменяемое свойство объекта (спецификация §11.4.1).
* eval не может инстанциировать переменные и функции в контексте вызова (спецификация §10.4.2).
* this не преобразуется в объект, а если значение this - undefined или null, то не преобразуется в глобальный объект (спецификация §10.4.3).
* eval и arguments - нельзя изменить или использовать в качестве имени (спецификация §11.4.4, §11.4.5, §11.13, §12.2.1, §12.10, §12.14.1, §13.1).
* нельзя использовать argument.caller и arguments.callee (спецификация §13.2).
* больше слов, зарезервированных для использования в будущем (спецификация §7.6.1.2).